(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@visactor/vchart')) :
    typeof define === 'function' && define.amd ? define(['exports', '@visactor/vchart'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["vchart-semi-theme"] = {}, global.VChart));
})(this, (function (exports, VChart) { 'use strict';

    const SEMI_FONT_FAMILY = 'Inter,-apple-system,BlinkMacSystemFont,Segoe UI,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Helvetica Neue,Helvetica,Arial,sans-serif';
    const THEME_MODE_ATTRIBUTE = 'theme-mode';

    const getTokenValue = (token, defaultValue, chartContainer) => {
      const value = token && getComputedStyle(null != chartContainer ? chartContainer : document.body).getPropertyValue(token) || defaultValue;
      return value && !isNaN(value[0]) ? `rgba(${value})` : value;
    };

    const observeAttribute = (element, attribute, callback) => {
      new MutationObserver(mutations => {
        mutations.forEach(mutation => {
          mutation.attributeName === attribute && callback(mutation);
        });
      }).observe(element, {
        attributes: !0
      });
    };

    const generateDataScheme = (mode, tokenMap, baseDataScheme, chartContainer) => tokenMap.map((item, i) => {
      const {
        scheme: scheme
      } = baseDataScheme[i];
      return Object.assign(Object.assign({}, item), {
        scheme: item.scheme.map((token, j) => getTokenValue("object" == typeof token ? token[mode] : token, null == scheme ? void 0 : scheme[j], chartContainer))
      });
    });
    const generatePalette = (mode, tokenMap, basePalette, chartContainer) => {
      const newPalette = {};
      return Object.keys(tokenMap).forEach(key => {
        const token = "object" == typeof tokenMap[key] ? tokenMap[key][mode] : tokenMap[key];
        newPalette[key] = getTokenValue(token, basePalette[key], chartContainer);
      }), newPalette;
    };

    const getCurrentMode = () => document.body.hasAttribute(THEME_MODE_ATTRIBUTE) && document.body.getAttribute(THEME_MODE_ATTRIBUTE) === 'dark'
        ? 'dark'
        : 'light';
    const generateThemeName = (mode) => `semiDesign${mode[0].toUpperCase()}${mode.slice(1)}`;
    const observeThemeSwitch = (callback) => {
        const observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                var _a;
                if (mutation.addedNodes.length === 1) {
                    const node = mutation.addedNodes[0];
                    if (node.tagName === 'LINK' && ((_a = node.getAttribute) === null || _a === void 0 ? void 0 : _a.call(node, 'semi-theme-switcher')) === 'true') {
                        callback(mutation, node);
                    }
                }
            });
        });
        observer.observe(document.body, { childList: true });
    };

    const colorScheme$1 = {
        default: {
            dataScheme: VChart.lightTheme.colorScheme.default.dataScheme,
            palette: {
                backgroundColor: '#16161a',
                borderColor: 'rgba(255,255,255,0.08)',
                shadowColor: 'rgba(0,0,0,0.25)',
                hoverBackgroundColor: 'rgba(255,255,255,0.12)',
                sliderRailColor: 'rgba(255,255,255,0.12)',
                sliderHandleColor: '#e4e7f5',
                sliderTrackColor: 'rgba(84,169,255,1)',
                popupBackgroundColor: '#43444a',
                primaryFontColor: 'rgba(249,249,249,1)',
                secondaryFontColor: 'rgba(249,249,249,0.8)',
                tertiaryFontColor: 'rgba(249,249,249,0.6)',
                axisLabelFontColor: 'rgba(249,249,249,0.6)',
                disableFontColor: 'rgba(249,249,249,0.35)',
                axisMarkerFontColor: '#16161a',
                axisGridColor: 'rgba(255,255,255,0.08)',
                axisDomainColor: 'rgba(255,255,255,0.08)',
                dataZoomHandleStrokeColor: 'rgba(46,50,56,0.13)',
                dataZoomChartColor: 'rgba(255,255,255,0.16)',
                playerControllerColor: 'rgba(84,169,255,1)',
                axisMarkerBackgroundColor: 'rgba(249,249,249,1)',
                markLabelBackgroundColor: 'rgba(255,255,255,0.08)',
                markLineStrokeColor: 'rgba(249,249,249,0.8)',
                dangerColor: 'rgba(252,114,90,1)',
                warningColor: 'rgba(255,174,67,1)',
                successColor: 'rgba(93,194,100,1)',
                infoColor: 'rgba(84,169,255,1)'
            }
        }
    };

    const semiDesignDark = {
        name: 'semiDesignDark',
        description: 'Semi Design - dark',
        type: 'dark',
        fontFamily: SEMI_FONT_FAMILY,
        colorScheme: colorScheme$1
    };

    const colorScheme = {
        default: {
            dataScheme: VChart.lightTheme.colorScheme.default.dataScheme,
            palette: {
                backgroundColor: 'rgba(255,255,255,1)',
                borderColor: 'rgba(28,31,35,0.08)',
                shadowColor: 'rgba(0,0,0,0.1)',
                hoverBackgroundColor: 'rgba(46,50,56,0.05)',
                sliderRailColor: 'rgba(46,50,56,0.05)',
                sliderHandleColor: 'rgba(255,255,255,1)',
                sliderTrackColor: 'rgba(0,100,250,1)',
                popupBackgroundColor: 'rgba(255,255,255,1)',
                primaryFontColor: 'rgba(28,31,35,1)',
                secondaryFontColor: 'rgba(28,31,35,0.8)',
                tertiaryFontColor: 'rgba(28,31,35,0.62)',
                axisLabelFontColor: 'rgba(28,31,35,0.62)',
                disableFontColor: 'rgba(28,31,35,0.35)',
                axisMarkerFontColor: 'rgba(255,255,255,1)',
                axisGridColor: 'rgba(28,31,35,0.08)',
                axisDomainColor: 'rgba(28,31,35,0.15)',
                dataZoomHandleStrokeColor: 'rgba(46,50,56,0.13)',
                dataZoomChartColor: 'rgba(46,50,56,0.09)',
                playerControllerColor: 'rgba(0,100,250,1)',
                axisMarkerBackgroundColor: 'rgba(28,31,35,1)',
                markLabelBackgroundColor: 'rgba(28,31,35,0.08)',
                markLineStrokeColor: 'rgba(28,31,35,0.8)',
                dangerColor: 'rgba(249,57,32,1)',
                warningColor: 'rgba(252,136,0,1)',
                successColor: 'rgba(59,179,70,1)',
                infoColor: 'rgba(0,100,250,1)'
            }
        }
    };

    const semiDesignLight = {
        name: 'semiDesignLight',
        description: 'Semi Design - light',
        type: 'light',
        fontFamily: SEMI_FONT_FAMILY,
        colorScheme
    };

    const paletteTokenMap = {
        backgroundColor: '--semi-color-bg-0',
        borderColor: '--semi-color-border',
        hoverBackgroundColor: '--semi-color-fill-0',
        sliderRailColor: '--semi-color-fill-0',
        sliderHandleColor: '--semi-white',
        sliderTrackColor: '--semi-color-primary',
        popupBackgroundColor: '--semi-color-bg-3',
        primaryFontColor: '--semi-color-text-0',
        secondaryFontColor: '--semi-color-text-1',
        tertiaryFontColor: '--semi-color-text-2',
        axisLabelFontColor: '--semi-color-text-0',
        disableFontColor: '--semi-color-disabled-text',
        axisMarkerFontColor: '--semi-color-bg-0',
        axisGridColor: '--semi-color-border',
        axisDomainColor: {
            light: '--semi-grey-9',
            dark: '--semi-color-border'
        },
        dataZoomHandleStrokeColor: {
            light: '--semi-color-fill-2'
        },
        dataZoomChartColor: '--semi-color-fill-1',
        playerControllerColor: '--semi-color-primary',
        axisMarkerBackgroundColor: '--semi-color-text-0',
        markLabelBackgroundColor: '--semi-color-border',
        markLineStrokeColor: '--semi-color-text-1',
        dangerColor: '--semi-color-danger',
        warningColor: '--semi-color-warning',
        successColor: '--semi-color-success',
        infoColor: '--semi-color-info'
    };
    const dataSchemeTokenMap = [
        {
            maxDomainLength: 10,
            scheme: [
                '--semi-color-data-0',
                '--semi-color-data-2',
                '--semi-color-data-4',
                '--semi-color-data-6',
                '--semi-color-data-8',
                '--semi-color-data-10',
                '--semi-color-data-12',
                '--semi-color-data-14',
                '--semi-color-data-16',
                '--semi-color-data-18'
            ]
        },
        {
            scheme: [
                '--semi-color-data-0',
                '--semi-color-data-1',
                '--semi-color-data-2',
                '--semi-color-data-3',
                '--semi-color-data-4',
                '--semi-color-data-5',
                '--semi-color-data-6',
                '--semi-color-data-7',
                '--semi-color-data-8',
                '--semi-color-data-9',
                '--semi-color-data-10',
                '--semi-color-data-11',
                '--semi-color-data-12',
                '--semi-color-data-13',
                '--semi-color-data-14',
                '--semi-color-data-15',
                '--semi-color-data-16',
                '--semi-color-data-17',
                '--semi-color-data-18',
                '--semi-color-data-19'
            ]
        }
    ];

    const baseThemeMap = {
        light: semiDesignLight,
        dark: semiDesignDark
    };
    const generateVChartSemiTheme = (mode, chartContainer) => {
        const baseTheme = baseThemeMap[mode];
        const { dataScheme, palette } = baseTheme.colorScheme.default;
        const colorScheme = {
            default: {
                dataScheme: generateDataScheme(mode, dataSchemeTokenMap, dataScheme, chartContainer),
                palette: generatePalette(mode, paletteTokenMap, palette, chartContainer)
            }
        };
        return Object.assign(Object.assign({}, baseTheme), { colorScheme });
    };

    const allThemeMap = new Map([
        [semiDesignLight.name, semiDesignLight],
        [semiDesignDark.name, semiDesignDark]
    ]);

    const initVChartSemiTheme = (options) => {
        const { defaultMode, isWatchingMode = true, isWatchingThemeSwitch = false } = options !== null && options !== void 0 ? options : {};
        switchVChartSemiTheme(false, defaultMode);
        if (isWatchingMode) {
            observeAttribute(document.body, THEME_MODE_ATTRIBUTE, () => switchVChartSemiTheme());
        }
        if (isWatchingThemeSwitch) {
            observeThemeSwitch(() => {
                const mode = getCurrentMode();
                const cacheColorScheme = JSON.stringify(generateVChartSemiTheme(mode).colorScheme);
                let times = 0;
                const timer = setInterval(() => {
                    const theme = generateVChartSemiTheme(mode);
                    if (times > 50 || cacheColorScheme !== JSON.stringify(theme.colorScheme)) {
                        switchVChartSemiTheme(true, mode, theme);
                        clearInterval(timer);
                    }
                    times++;
                }, 100);
            });
        }
    };
    const switchVChartSemiTheme = (force, mode, theme) => {
        if (!mode) {
            mode = getCurrentMode();
        }
        const themeName = generateThemeName(mode);
        if (!force && VChart.ThemeManager.getCurrentTheme() === themeName) {
            return;
        }
        else if (force) {
            VChart.ThemeManager.removeTheme(themeName);
        }
        if (!VChart.ThemeManager.themeExist(themeName)) {
            VChart.ThemeManager.registerTheme(themeName, theme !== null && theme !== void 0 ? theme : generateVChartSemiTheme(mode));
        }
        VChart.ThemeManager.setCurrentTheme(themeName);
    };

    exports.allThemeMap = allThemeMap;
    exports.generateVChartSemiTheme = generateVChartSemiTheme;
    exports.initVChartSemiTheme = initVChartSemiTheme;
    exports.semiDesignDark = semiDesignDark;
    exports.semiDesignLight = semiDesignLight;
    exports.switchVChartSemiTheme = switchVChartSemiTheme;

}));
