# 执行计划：Supabase密钥池 + 消费明细API

> 文档版本: v1.0
> 创建日期: 2025-01-XX
> 预计工期: 5-7天

---

## 一、任务概述

### 1.1 任务清单

| 任务ID | 任务名称 | 优先级 | 预计工期 |
|--------|----------|--------|----------|
| TASK-01 | Supabase密钥池 + Webhook同步 | P0 | 3-4天 |
| TASK-02 | 消费明细API (方案A) | P0 | 2-3天 |

### 1.2 依赖关系

```
TASK-01 (密钥池) ───┬───▶ 可独立实施
                    │
TASK-02 (消费明细) ─┴───▶ 可独立实施，但与TASK-01配合效果更佳
```

---

## 二、TASK-01: Supabase密钥池 + Webhook同步

### 2.1 目标

实现用户注册时自动在Supabase生成密钥，并通过Webhook同步到new-api。

### 2.2 可行性验证阶段 ⭐

#### 阶段0.1: 验证new-api Token导入可行性 (0.5天)

**验证目标**: 确认new-api可以接受外部生成的密钥

**验证步骤**:

1. **分析现有Token创建逻辑**
   ```
   文件: controller/token.go:137-184
   关键点:
   - GenerateKey() 生成48字符密钥
   - cleanToken.Insert() 插入数据库
   - 数据库有唯一索引约束
   ```

2. **验证密钥格式兼容性**
   ```go
   // common/utils.go:161
   const keyChars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

   // 验证: Supabase生成的密钥是否使用相同字符集
   // 验证: 48字符长度是否为硬性要求
   ```

3. **测试手动插入Token**
   ```sql
   -- 在new-api数据库中测试
   INSERT INTO tokens (user_id, key, name, status, created_time, remain_quota, unlimited_quota)
   VALUES (1, 'test48charkey...', 'external_test', 1, UNIX_TIMESTAMP(), 0, 1);

   -- 验证该Token是否可正常使用
   curl -H "Authorization: Bearer sk-test48charkey..." https://api.xxx/v1/models
   ```

**验证通过标准**:
- [ ] 外部插入的Token可通过API正常使用
- [ ] 密钥格式不影响认证流程
- [ ] 无需修改现有验证逻辑

#### 阶段0.2: 验证Supabase Webhook能力 (0.5天)

**验证目标**: 确认Supabase可以在数据变更时触发外部Webhook

**验证步骤**:

1. **检查Supabase项目配置**
   - 是否启用了Database Webhooks功能
   - 是否有Edge Functions可用额度

2. **创建测试Webhook**
   ```sql
   -- 测试触发器
   CREATE OR REPLACE FUNCTION test_webhook()
   RETURNS TRIGGER AS $$
   BEGIN
     PERFORM net.http_post(
       url := 'https://webhook.site/xxx',
       body := json_build_object('test', 'data')::jsonb
     );
     RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;
   ```

3. **验证网络连通性**
   - Supabase → Railway new-api 网络是否可达
   - 是否需要配置IP白名单

**验证通过标准**:
- [ ] Supabase可成功调用外部HTTP接口
- [ ] 延迟在可接受范围内 (<2s)
- [ ] 错误重试机制可配置

---

### 2.3 实施阶段

#### 阶段1: Supabase密钥池表结构 (0.5天)

**任务清单**:

- [ ] 1.1 创建api_keys表
  ```sql
  CREATE TABLE api_keys (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
      key TEXT NOT NULL UNIQUE,
      name TEXT DEFAULT 'default',
      status INTEGER DEFAULT 1,
      newapi_synced BOOLEAN DEFAULT FALSE,
      newapi_token_id INTEGER,
      sync_error TEXT,
      created_at TIMESTAMPTZ DEFAULT NOW(),
      updated_at TIMESTAMPTZ DEFAULT NOW()
  );
  ```

- [ ] 1.2 创建密钥生成函数
  ```sql
  CREATE OR REPLACE FUNCTION generate_api_key()
  RETURNS TEXT AS $$
  DECLARE
      chars TEXT := '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
      result TEXT := '';
      i INTEGER;
  BEGIN
      FOR i IN 1..48 LOOP
          result := result || substr(chars, floor(random() * 62 + 1)::integer, 1);
      END LOOP;
      RETURN result;
  END;
  $$ LANGUAGE plpgsql;
  ```

- [ ] 1.3 创建RLS策略
  ```sql
  ALTER TABLE api_keys ENABLE ROW LEVEL SECURITY;

  CREATE POLICY "Users can view own keys"
      ON api_keys FOR SELECT
      USING (auth.uid() = user_id);
  ```

#### 阶段2: new-api Token导入接口 (1天)

**任务清单**:

- [ ] 2.1 新增导入接口 `controller/token_import.go`
  ```go
  // POST /api/token/import
  type ImportTokenRequest struct {
      Key            string `json:"key" binding:"required,len=48"`
      ExternalUserId string `json:"external_user_id" binding:"required"`
      Name           string `json:"name"`
      UnlimitedQuota bool   `json:"unlimited_quota"`
  }

  func ImportToken(c *gin.Context) {
      // 1. 验证管理员权限或Service Token
      // 2. 检查密钥是否已存在
      // 3. 查找或创建internal user (by external_user_id)
      // 4. 创建Token记录
      // 5. 返回token_id
  }
  ```

- [ ] 2.2 Token模型新增字段 `model/token.go`
  ```go
  type Token struct {
      // 现有字段...
      ExternalUserId string `json:"external_user_id" gorm:"index;size:64"`
  }
  ```

- [ ] 2.3 数据库迁移
  ```sql
  ALTER TABLE tokens ADD COLUMN external_user_id VARCHAR(64);
  CREATE INDEX idx_tokens_external_user_id ON tokens(external_user_id);
  ```

- [ ] 2.4 注册路由 `router/api-router.go`
  ```go
  // 在adminRoute组下添加
  adminRoute.POST("/token/import", controller.ImportToken)
  ```

- [ ] 2.5 单元测试
  - 正常导入测试
  - 重复导入测试
  - 无效密钥格式测试

#### 阶段3: Supabase Webhook触发器 (1天)

**任务清单**:

- [ ] 3.1 创建同步函数
  ```sql
  CREATE OR REPLACE FUNCTION sync_key_to_newapi()
  RETURNS TRIGGER AS $$
  DECLARE
      response_status INTEGER;
      response_body TEXT;
  BEGIN
      -- 调用new-api导入接口
      SELECT status, content INTO response_status, response_body
      FROM net.http_post(
          url := 'https://your-newapi.railway.app/api/token/import',
          headers := jsonb_build_object(
              'Content-Type', 'application/json',
              'Authorization', 'Bearer ' || current_setting('app.newapi_admin_token')
          ),
          body := jsonb_build_object(
              'key', replace(NEW.key, 'sk-', ''),
              'external_user_id', NEW.user_id::text,
              'name', NEW.name,
              'unlimited_quota', true
          )
      );

      -- 更新同步状态
      IF response_status = 200 THEN
          UPDATE api_keys
          SET newapi_synced = true,
              newapi_token_id = (response_body::jsonb->'data'->>'token_id')::integer,
              sync_error = null
          WHERE id = NEW.id;
      ELSE
          UPDATE api_keys
          SET sync_error = response_body
          WHERE id = NEW.id;
      END IF;

      RETURN NEW;
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;
  ```

- [ ] 3.2 创建触发器
  ```sql
  CREATE TRIGGER trigger_sync_key_to_newapi
      AFTER INSERT ON api_keys
      FOR EACH ROW
      EXECUTE FUNCTION sync_key_to_newapi();
  ```

- [ ] 3.3 用户注册时自动创建密钥
  ```sql
  CREATE OR REPLACE FUNCTION create_default_api_key()
  RETURNS TRIGGER AS $$
  BEGIN
      INSERT INTO api_keys (user_id, key, name)
      VALUES (NEW.id, 'sk-' || generate_api_key(), 'default');
      RETURN NEW;
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;

  CREATE TRIGGER trigger_create_default_key
      AFTER INSERT ON auth.users
      FOR EACH ROW
      EXECUTE FUNCTION create_default_api_key();
  ```

#### 阶段4: 集成测试 (0.5天)

**测试用例**:

- [ ] 4.1 新用户注册流程测试
  1. 在门户注册新用户
  2. 验证api_keys表有记录
  3. 验证new-api tokens表有对应记录
  4. 使用密钥调用API验证可用性

- [ ] 4.2 错误处理测试
  1. new-api不可用时的处理
  2. 重复密钥的处理
  3. Webhook超时的处理

- [ ] 4.3 性能测试
  1. Webhook响应时间
  2. 并发注册压测

---

### 2.4 交付物

| 交付物 | 说明 |
|--------|------|
| Supabase SQL迁移脚本 | 包含表结构、函数、触发器 |
| new-api代码变更 | token_import.go, token.go, api-router.go |
| 测试报告 | 功能测试、集成测试结果 |
| 部署文档 | 环境变量配置、部署步骤 |

---

## 三、TASK-02: 消费明细API (方案A)

### 3.1 目标

基于密钥认证，提供完整的消费数据查询API，支持门户展示消费明细图表。

### 3.2 可行性验证阶段 ⭐

#### 阶段0.1: 验证数据完整性 (0.5天)

**验证目标**: 确认logs表数据可支持完整的消费明细展示

**验证步骤**:

1. **检查logs表索引**
   ```sql
   -- 验证token_id索引存在
   SHOW INDEX FROM logs WHERE Key_name LIKE '%token%';
   ```

2. **验证数据关联**
   ```sql
   -- 抽样检查token_id是否正确记录
   SELECT
       l.token_id,
       t.key,
       COUNT(*) as log_count,
       SUM(l.quota) as total_quota
   FROM logs l
   JOIN tokens t ON l.token_id = t.id
   WHERE l.type = 2  -- LogTypeConsume
   GROUP BY l.token_id, t.key
   LIMIT 10;
   ```

3. **验证时间范围查询性能**
   ```sql
   EXPLAIN ANALYZE
   SELECT * FROM logs
   WHERE token_id = ?
   AND type = 2
   AND created_at BETWEEN ? AND ?
   LIMIT 100;
   ```

**验证通过标准**:
- [ ] token_id字段有索引
- [ ] 所有消费记录都有正确的token_id
- [ ] 时间范围查询性能可接受 (<100ms)

#### 阶段0.2: 验证现有API基础 (0.5天)

**验证目标**: 确认可以在现有API基础上扩展

**验证步骤**:

1. **测试现有GetTokenUsage接口**
   ```bash
   curl -H "Authorization: Bearer sk-xxx" \
        https://api.xxx/api/usage/token/
   ```

2. **分析返回数据结构**
   - 是否包含足够的基础信息
   - 是否需要补充字段

3. **确认TokenAuth中间件可复用**
   ```
   文件: middleware/auth.go:178-315
   验证: 密钥验证流程是否可直接复用
   ```

**验证通过标准**:
- [ ] 现有接口正常工作
- [ ] TokenAuth中间件可直接复用
- [ ] 无需修改认证逻辑

---

### 3.3 实施阶段

#### 阶段1: 数据模型层 (0.5天)

**任务清单**:

- [ ] 1.1 新建统计模型 `model/log_stats.go`
  ```go
  package model

  // ConsumptionSummary 消费汇总
  type ConsumptionSummary struct {
      TotalQuota    int64   `json:"total_quota"`
      TotalRequests int64   `json:"total_requests"`
      TotalTokens   int64   `json:"total_tokens"`
      AvgLatencyMs  int     `json:"avg_latency_ms"`
  }

  // ModelConsumption 按模型分组的消费
  type ModelConsumption struct {
      ModelName  string  `json:"model_name"`
      Quota      int64   `json:"quota"`
      Requests   int64   `json:"requests"`
      Tokens     int64   `json:"tokens"`
      Percentage float64 `json:"percentage"`
  }

  // DailyConsumption 按日期分组的消费
  type DailyConsumption struct {
      Date     string `json:"date"`
      Quota    int64  `json:"quota"`
      Requests int64  `json:"requests"`
      Tokens   int64  `json:"tokens"`
  }

  // HourlyConsumption 按小时分组的消费
  type HourlyConsumption struct {
      Hour     string `json:"hour"`
      Quota    int64  `json:"quota"`
      Requests int64  `json:"requests"`
  }
  ```

- [ ] 1.2 实现查询函数
  ```go
  // GetTokenConsumptionSummary 获取Token消费汇总
  func GetTokenConsumptionSummary(tokenId int, start, end int64) (*ConsumptionSummary, error)

  // GetTokenConsumptionByModel 按模型分组统计
  func GetTokenConsumptionByModel(tokenId int, start, end int64) ([]ModelConsumption, error)

  // GetTokenConsumptionByDay 按日期分组统计
  func GetTokenConsumptionByDay(tokenId int, start, end int64) ([]DailyConsumption, error)

  // GetTokenRecentLogs 获取最近消费记录
  func GetTokenRecentLogs(tokenId int, limit int) ([]*Log, error)
  ```

#### 阶段2: API控制器层 (0.5天)

**任务清单**:

- [ ] 2.1 新建控制器 `controller/token_usage.go`
  ```go
  package controller

  // GetTokenDetail 获取消费详情
  // GET /api/usage/token/detail?start=xxx&end=xxx
  func GetTokenDetail(c *gin.Context) {
      tokenId := c.GetInt("token_id")
      start, _ := strconv.ParseInt(c.Query("start"), 10, 64)
      end, _ := strconv.ParseInt(c.Query("end"), 10, 64)

      // 默认查询最近30天
      if end == 0 {
          end = time.Now().Unix()
      }
      if start == 0 {
          start = end - 30*24*3600
      }

      summary, _ := model.GetTokenConsumptionSummary(tokenId, start, end)
      byModel, _ := model.GetTokenConsumptionByModel(tokenId, start, end)
      byDay, _ := model.GetTokenConsumptionByDay(tokenId, start, end)
      recentLogs, _ := model.GetTokenRecentLogs(tokenId, 20)

      c.JSON(200, gin.H{
          "success": true,
          "data": gin.H{
              "summary":     summary,
              "by_model":    byModel,
              "by_day":      byDay,
              "recent_logs": recentLogs,
          },
      })
  }

  // GetTokenChart 获取图表数据
  // GET /api/usage/token/chart?start=xxx&end=xxx&granularity=day
  func GetTokenChart(c *gin.Context)

  // GetTokenLogs 获取消费日志（分页）
  // GET /api/usage/token/logs?page=1&page_size=20
  func GetTokenLogs(c *gin.Context)
  ```

#### 阶段3: 路由注册 (0.5天)

**任务清单**:

- [ ] 3.1 更新路由 `router/api-router.go`
  ```go
  usageRoute := apiRouter.Group("/usage")
  usageRoute.Use(middleware.CriticalRateLimit())
  {
      tokenUsageRoute := usageRoute.Group("/token")
      tokenUsageRoute.Use(middleware.TokenAuth())
      {
          tokenUsageRoute.GET("/", controller.GetTokenUsage)       // 现有
          tokenUsageRoute.GET("/detail", controller.GetTokenDetail) // 新增
          tokenUsageRoute.GET("/chart", controller.GetTokenChart)   // 新增
          tokenUsageRoute.GET("/logs", controller.GetTokenLogs)     // 新增
      }
  }
  ```

- [ ] 3.2 添加CORS支持（如需跨域）
  ```go
  tokenUsageRoute.Use(middleware.CORS())
  ```

#### 阶段4: 单元测试与集成测试 (0.5天)

**测试用例**:

- [ ] 4.1 单元测试
  - GetTokenConsumptionSummary 测试
  - GetTokenConsumptionByModel 测试
  - GetTokenConsumptionByDay 测试
  - 空数据处理测试
  - 时间范围边界测试

- [ ] 4.2 API集成测试
  ```bash
  # 测试消费详情
  curl -H "Authorization: Bearer sk-xxx" \
       "https://api.xxx/api/usage/token/detail?start=1704067200&end=1704153600"

  # 测试图表数据
  curl -H "Authorization: Bearer sk-xxx" \
       "https://api.xxx/api/usage/token/chart?granularity=day"

  # 测试日志分页
  curl -H "Authorization: Bearer sk-xxx" \
       "https://api.xxx/api/usage/token/logs?page=1&page_size=10"
  ```

- [ ] 4.3 性能测试
  - 大数据量下的查询性能
  - 并发请求压测

---

### 3.4 交付物

| 交付物 | 说明 |
|--------|------|
| model/log_stats.go | 统计数据模型和查询函数 |
| controller/token_usage.go | API控制器 |
| router/api-router.go | 路由更新 |
| 测试用例 | 单元测试和集成测试 |
| API文档 | 接口说明文档 |

---

## 四、风险管理

### 4.1 技术风险

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| Supabase Webhook不稳定 | 密钥同步失败 | 添加重试机制和手动同步入口 |
| 大数据量查询慢 | 用户体验差 | 添加合适的索引和查询缓存 |
| new-api服务不可用 | 无法展示消费数据 | 考虑本地缓存或降级展示 |

### 4.2 回滚计划

1. **密钥池回滚**
   - 保留原有密钥分配逻辑
   - 新旧机制可并行运行

2. **消费明细API回滚**
   - 新API独立部署，不影响现有功能
   - 可随时禁用新接口

---

## 五、时间线

```
Week 1
├── Day 1-2: 可行性验证 (TASK-01 + TASK-02)
│   ├── 验证Token导入可行性
│   ├── 验证Webhook能力
│   ├── 验证数据完整性
│   └── 验证现有API基础
│
├── Day 3: TASK-01 阶段1-2
│   ├── Supabase表结构
│   └── new-api导入接口
│
├── Day 4: TASK-01 阶段3
│   └── Webhook触发器
│
└── Day 5: TASK-01 阶段4 + TASK-02 阶段1-2
    ├── 集成测试
    └── 数据模型和控制器

Week 2
├── Day 6: TASK-02 阶段3-4
│   ├── 路由注册
│   └── 测试
│
└── Day 7: 联调与部署
    ├── 端到端测试
    └── 生产环境部署
```

---

## 六、验收标准

### 6.1 TASK-01 验收标准

- [ ] 新用户注册后自动生成密钥
- [ ] 密钥自动同步到new-api
- [ ] 同步失败有错误记录和重试机制
- [ ] 用户可在门户查看自己的密钥

### 6.2 TASK-02 验收标准

- [ ] `/api/usage/token/detail` 返回完整消费数据
- [ ] 按模型分组数据准确
- [ ] 按日期分组数据准确
- [ ] 分页查询正常工作
- [ ] 查询性能在可接受范围内 (<500ms)

---

## 附录

### A. 环境变量配置

**Supabase**:
```
app.newapi_admin_token = "xxx"  -- new-api管理员Token
app.newapi_base_url = "https://xxx.railway.app"
```

**new-api**:
```
EXTERNAL_TOKEN_IMPORT_ENABLED=true
```

### B. SQL脚本索引

| 脚本 | 用途 |
|------|------|
| 01_create_api_keys_table.sql | 创建密钥池表 |
| 02_create_key_generator.sql | 密钥生成函数 |
| 03_create_sync_webhook.sql | Webhook同步触发器 |
| 04_create_user_trigger.sql | 用户注册触发器 |
