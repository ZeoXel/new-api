package bltcy

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"one-api/common"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

// ğŸ†• ä¿®å¤åçš„ DoRequest æ–¹æ³•
// æ·»åŠ  multipart/form-data çš„ç‰¹æ®Šå¤„ç†
func (a *Adaptor) DoRequest(c *gin.Context, baseURL string, channelKey string) (*http.Response, error) {
	var requestBody []byte
	var contentType string
	var requestPath string
	var requestQuery string
	var err error

	// æ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„åŸå§‹è¯·æ±‚ä½“
	if originalBody, exists := c.Get("bltcy_original_body"); exists {
		if bodyBytes, ok := originalBody.([]byte); ok {
			requestBody = bodyBytes
		}
	}

	// æ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„åŸå§‹è·¯å¾„
	if originalPath, exists := c.Get("bltcy_original_path"); exists {
		if pathStr, ok := originalPath.(string); ok {
			requestPath = pathStr
		}
	}

	// æ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„åŸå§‹æŸ¥è¯¢å‚æ•°
	if originalQuery, exists := c.Get("bltcy_original_query"); exists {
		if queryStr, ok := originalQuery.(string); ok {
			requestQuery = queryStr
		}
	}

	// å¦‚æœæ²¡æœ‰ä¿å­˜çš„åŸå§‹è¯·æ±‚ï¼Œåˆ¤æ–­è¯·æ±‚ç±»å‹å¹¶å¤„ç†
	if len(requestBody) == 0 {
		currentContentType := c.Request.Header.Get("Content-Type")

		// ğŸ†• æ£€æŸ¥æ˜¯å¦æ˜¯ multipart è¯·æ±‚
		if strings.Contains(currentContentType, "multipart/form-data") {
			fmt.Printf("[DEBUG Bltcy] Detected multipart request, using special handler\n")
			requestBody, contentType, err = handleMultipartRequest(c)
			if err != nil {
				return nil, fmt.Errorf("failed to handle multipart request: %w", err)
			}
		} else {
			// åŸæœ‰çš„å¤„ç†é€»è¾‘ï¼ˆJSONç­‰ï¼‰
			requestBody, err = common.GetRequestBody(c)
			if err != nil {
				return nil, fmt.Errorf("failed to read request body: %w", err)
			}
			contentType = currentContentType
		}
	} else {
		// ä½¿ç”¨ä¿å­˜çš„åŸå§‹è¯·æ±‚ä½“æ—¶ï¼Œä¿æŒåŸæœ‰çš„ Content-Type
		contentType = c.Request.Header.Get("Content-Type")
	}

	// å¦‚æœè·¯å¾„å’ŒæŸ¥è¯¢å‚æ•°æœªä¿å­˜ï¼Œä½¿ç”¨å½“å‰è¯·æ±‚çš„
	if requestPath == "" {
		requestPath = c.Request.URL.Path
	}
	if requestQuery == "" {
		requestQuery = c.Request.URL.RawQuery
	}

	// æ„å»ºç›®æ ‡URL
	targetURL := baseURL + requestPath
	if requestQuery != "" {
		targetURL += "?" + requestQuery
	}

	// è°ƒè¯•ä¿¡æ¯
	fmt.Printf("[DEBUG Bltcy] Method: %s, targetURL: %s, bodyLen: %d, contentType: %s\n",
		c.Request.Method, targetURL, len(requestBody), contentType)

	// åˆ›å»ºè¯·æ±‚
	req, err := http.NewRequest(c.Request.Method, targetURL, bytes.NewReader(requestBody))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// è®¾ç½®è¶…æ—¶ä¸Šä¸‹æ–‡ï¼ˆå¢åŠ åˆ° 300 ç§’ä»¥æ”¯æŒå¤§å›¾ç‰‡ä¸Šä¼ ï¼‰
	timeout := time.Second * 300
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	req = req.WithContext(ctx)

	// è®¾ç½®è¯·æ±‚å¤´
	req.Header.Set("Content-Type", contentType) // ğŸ†• ä½¿ç”¨å¤„ç†åçš„ Content-Type
	req.Header.Set("Accept", c.Request.Header.Get("Accept"))
	req.Header.Set("Authorization", "Bearer "+channelKey)

	// å¤åˆ¶å…¶ä»–è‡ªå®šä¹‰å¤´ï¼ˆæ’é™¤å·²å¤„ç†çš„ï¼‰
	for key, values := range c.Request.Header {
		if key != "Authorization" && key != "Content-Type" && key != "Accept" && key != "Host" {
			for _, value := range values {
				req.Header.Add(key, value)
			}
		}
	}

	// åˆ›å»ºè‡ªå®šä¹‰ HTTP å®¢æˆ·ç«¯
	client := &http.Client{
		Timeout: timeout,
		Transport: &http.Transport{
			TLSHandshakeTimeout:   60 * time.Second,
			ResponseHeaderTimeout: 60 * time.Second,
			ExpectContinueTimeout: 1 * time.Second,
			DisableKeepAlives:     false,
			MaxIdleConns:          100,
			IdleConnTimeout:       90 * time.Second,
		},
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to send request to legacy gateway: %w", err)
	}

	return resp, nil
}

// ğŸ†• å¤„ç† multipart/form-data è¯·æ±‚
// å‚è€ƒ OpenAI adaptor çš„å®ç°
func handleMultipartRequest(c *gin.Context) ([]byte, string, error) {
	// è§£æ multipart è¡¨å•ï¼ˆæœ€å¤§ 32MB å†…å­˜ï¼‰
	if err := c.Request.ParseMultipartForm(32 << 20); err != nil {
		return nil, "", fmt.Errorf("failed to parse multipart form: %w", err)
	}

	if c.Request.MultipartForm == nil {
		return nil, "", fmt.Errorf("multipart form is nil after parsing")
	}

	// åˆ›å»ºæ–°çš„ multipart writer
	var requestBody bytes.Buffer
	writer := multipart.NewWriter(&requestBody)

	// å¤åˆ¶æ‰€æœ‰è¡¨å•å­—æ®µï¼ˆéæ–‡ä»¶ï¼‰
	for key, values := range c.Request.MultipartForm.Value {
		for _, value := range values {
			if err := writer.WriteField(key, value); err != nil {
				return nil, "", fmt.Errorf("failed to write field %s: %w", key, err)
			}
		}
	}

	// å¤åˆ¶æ‰€æœ‰æ–‡ä»¶å­—æ®µ
	for key, files := range c.Request.MultipartForm.File {
		for _, fileHeader := range files {
			fmt.Printf("[DEBUG Bltcy] Processing file field: %s, filename: %s, size: %d bytes\n",
				key, fileHeader.Filename, fileHeader.Size)

			// æ‰“å¼€æ–‡ä»¶
			file, err := fileHeader.Open()
			if err != nil {
				return nil, "", fmt.Errorf("failed to open file %s: %w", fileHeader.Filename, err)
			}
			defer file.Close()

			// åˆ›å»ºæ–‡ä»¶å­—æ®µ
			part, err := writer.CreateFormFile(key, fileHeader.Filename)
			if err != nil {
				return nil, "", fmt.Errorf("failed to create form file for %s: %w", fileHeader.Filename, err)
			}

			// å¤åˆ¶æ–‡ä»¶å†…å®¹
			written, err := io.Copy(part, file)
			if err != nil {
				return nil, "", fmt.Errorf("failed to copy file %s: %w", fileHeader.Filename, err)
			}

			fmt.Printf("[DEBUG Bltcy] Copied %d bytes for file %s\n", written, fileHeader.Filename)
		}
	}

	// å…³é—­ writer ä»¥è®¾ç½®ç»“æŸè¾¹ç•Œ
	if err := writer.Close(); err != nil {
		return nil, "", fmt.Errorf("failed to close multipart writer: %w", err)
	}

	// è¿”å›æ–°çš„è¯·æ±‚ä½“å’Œ Content-Typeï¼ˆåŒ…å«æ–°çš„ boundaryï¼‰
	newContentType := writer.FormDataContentType()
	fmt.Printf("[DEBUG Bltcy] Created new multipart body, size: %d bytes, Content-Type: %s\n",
		requestBody.Len(), newContentType)

	return requestBody.Bytes(), newContentType, nil
}
