package bltcy

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"one-api/common"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

// 🆕 修复后的 DoRequest 方法
// 添加 multipart/form-data 的特殊处理
func (a *Adaptor) DoRequest(c *gin.Context, baseURL string, channelKey string) (*http.Response, error) {
	var requestBody []byte
	var contentType string
	var requestPath string
	var requestQuery string
	var err error

	// 检查是否有保存的原始请求体
	if originalBody, exists := c.Get("bltcy_original_body"); exists {
		if bodyBytes, ok := originalBody.([]byte); ok {
			requestBody = bodyBytes
		}
	}

	// 检查是否有保存的原始路径
	if originalPath, exists := c.Get("bltcy_original_path"); exists {
		if pathStr, ok := originalPath.(string); ok {
			requestPath = pathStr
		}
	}

	// 检查是否有保存的原始查询参数
	if originalQuery, exists := c.Get("bltcy_original_query"); exists {
		if queryStr, ok := originalQuery.(string); ok {
			requestQuery = queryStr
		}
	}

	// 如果没有保存的原始请求，判断请求类型并处理
	if len(requestBody) == 0 {
		currentContentType := c.Request.Header.Get("Content-Type")

		// 🆕 检查是否是 multipart 请求
		if strings.Contains(currentContentType, "multipart/form-data") {
			fmt.Printf("[DEBUG Bltcy] Detected multipart request, using special handler\n")
			requestBody, contentType, err = handleMultipartRequest(c)
			if err != nil {
				return nil, fmt.Errorf("failed to handle multipart request: %w", err)
			}
		} else {
			// 原有的处理逻辑（JSON等）
			requestBody, err = common.GetRequestBody(c)
			if err != nil {
				return nil, fmt.Errorf("failed to read request body: %w", err)
			}
			contentType = currentContentType
		}
	} else {
		// 使用保存的原始请求体时，保持原有的 Content-Type
		contentType = c.Request.Header.Get("Content-Type")
	}

	// 如果路径和查询参数未保存，使用当前请求的
	if requestPath == "" {
		requestPath = c.Request.URL.Path
	}
	if requestQuery == "" {
		requestQuery = c.Request.URL.RawQuery
	}

	// 构建目标URL
	targetURL := baseURL + requestPath
	if requestQuery != "" {
		targetURL += "?" + requestQuery
	}

	// 调试信息
	fmt.Printf("[DEBUG Bltcy] Method: %s, targetURL: %s, bodyLen: %d, contentType: %s\n",
		c.Request.Method, targetURL, len(requestBody), contentType)

	// 创建请求
	req, err := http.NewRequest(c.Request.Method, targetURL, bytes.NewReader(requestBody))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// 设置超时上下文（增加到 300 秒以支持大图片上传）
	timeout := time.Second * 300
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	req = req.WithContext(ctx)

	// 设置请求头
	req.Header.Set("Content-Type", contentType) // 🆕 使用处理后的 Content-Type
	req.Header.Set("Accept", c.Request.Header.Get("Accept"))
	req.Header.Set("Authorization", "Bearer "+channelKey)

	// 复制其他自定义头（排除已处理的）
	for key, values := range c.Request.Header {
		if key != "Authorization" && key != "Content-Type" && key != "Accept" && key != "Host" {
			for _, value := range values {
				req.Header.Add(key, value)
			}
		}
	}

	// 创建自定义 HTTP 客户端
	client := &http.Client{
		Timeout: timeout,
		Transport: &http.Transport{
			TLSHandshakeTimeout:   60 * time.Second,
			ResponseHeaderTimeout: 60 * time.Second,
			ExpectContinueTimeout: 1 * time.Second,
			DisableKeepAlives:     false,
			MaxIdleConns:          100,
			IdleConnTimeout:       90 * time.Second,
		},
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to send request to legacy gateway: %w", err)
	}

	return resp, nil
}

// 🆕 处理 multipart/form-data 请求
// 参考 OpenAI adaptor 的实现
func handleMultipartRequest(c *gin.Context) ([]byte, string, error) {
	// 解析 multipart 表单（最大 32MB 内存）
	if err := c.Request.ParseMultipartForm(32 << 20); err != nil {
		return nil, "", fmt.Errorf("failed to parse multipart form: %w", err)
	}

	if c.Request.MultipartForm == nil {
		return nil, "", fmt.Errorf("multipart form is nil after parsing")
	}

	// 创建新的 multipart writer
	var requestBody bytes.Buffer
	writer := multipart.NewWriter(&requestBody)

	// 复制所有表单字段（非文件）
	for key, values := range c.Request.MultipartForm.Value {
		for _, value := range values {
			if err := writer.WriteField(key, value); err != nil {
				return nil, "", fmt.Errorf("failed to write field %s: %w", key, err)
			}
		}
	}

	// 复制所有文件字段
	for key, files := range c.Request.MultipartForm.File {
		for _, fileHeader := range files {
			fmt.Printf("[DEBUG Bltcy] Processing file field: %s, filename: %s, size: %d bytes\n",
				key, fileHeader.Filename, fileHeader.Size)

			// 打开文件
			file, err := fileHeader.Open()
			if err != nil {
				return nil, "", fmt.Errorf("failed to open file %s: %w", fileHeader.Filename, err)
			}
			defer file.Close()

			// 创建文件字段
			part, err := writer.CreateFormFile(key, fileHeader.Filename)
			if err != nil {
				return nil, "", fmt.Errorf("failed to create form file for %s: %w", fileHeader.Filename, err)
			}

			// 复制文件内容
			written, err := io.Copy(part, file)
			if err != nil {
				return nil, "", fmt.Errorf("failed to copy file %s: %w", fileHeader.Filename, err)
			}

			fmt.Printf("[DEBUG Bltcy] Copied %d bytes for file %s\n", written, fileHeader.Filename)
		}
	}

	// 关闭 writer 以设置结束边界
	if err := writer.Close(); err != nil {
		return nil, "", fmt.Errorf("failed to close multipart writer: %w", err)
	}

	// 返回新的请求体和 Content-Type（包含新的 boundary）
	newContentType := writer.FormDataContentType()
	fmt.Printf("[DEBUG Bltcy] Created new multipart body, size: %d bytes, Content-Type: %s\n",
		requestBody.Len(), newContentType)

	return requestBody.Bytes(), newContentType, nil
}
